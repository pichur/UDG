Checking unit: 10
Show only functions ≥ 0.100 s
Timer unit: 1e-07 s

Total time: 0.326925 s

Could not find file <string>
Are you sure you are running this program from the same directory
that you ran the profiler from?
Continuing without the function's contents.

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     2                                           
     3    149562    1318466.0      8.8     40.3  
     4    149562     915200.0      6.1     28.0  
     5    149554    1035586.0      6.9     31.7  

Total time: 0.304429 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: _get_from_disk_cache at line 231

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   231                                           def _get_from_disk_cache(radius: int, connected: int = 1) -> np.ndarray:
   232    182125    1441862.0      7.9     47.4      if radius not in _disk_cache:
   233         2         19.0      9.5      0.0          if opts.disk_mode== 'sq_center':
   234         2      54093.0  27046.5      1.8              _create_disk_sq_center(radius, connected)
   235                                                   elif opts.disk_mode == 'sq_border':
   236                                                       _create_disk_sq_border(radius, connected)
   237                                                   elif opts.disk_mode == 'hex_center':
   238                                                       _create_disk_hex_center(radius, connected)
   239                                                   else:
   240                                                       raise ValueError(f'Not supported disk mode: {opts.disk_mode}')
   241                                               
   242    182125    1548314.0      8.5     50.9      return _disk_cache[radius][connected]

Total time: 1.47862 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: DiscreteDisk.__init__ at line 278

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   278                                               def __init__(self, data: np.ndarray, rest: np.uint8, x: int, y: int, _shared: bool = False):
   279    364243    3771283.0     10.4     25.5          self.data = data
   280    364243    2829577.0      7.8     19.1          self.rest = rest
   281    364243    2710298.0      7.4     18.3          self.x = x
   282    364243    2622832.0      7.2     17.7          self.y = y
   283    364243    2852219.0      7.8     19.3          self._shared = _shared

Total time: 2.65203 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: DiscreteDisk.disk at line 301

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   301                                               @classmethod
   302                                               def disk(cls, radius: int = 4, x: int = 0, y: int = 0, connected: int = 1) -> "DiscreteDisk":
   303    182125    8144297.0     44.7     30.7          M = _get_from_disk_cache(radius, connected)
   304                                           
   305    182125    1298006.0      7.1      4.9          if opts.disk_mode == 'hex_center':
   306                                                       x_shift = x - _hex_x_range(radius)
   307                                                       y_shift = y - 2 * radius
   308                                                   else:
   309    182125    1637853.0      9.0      6.2              x_shift = x - radius
   310    182125    1278641.0      7.0      4.8              y_shift = y - radius
   311                                                   
   312    182125   14161514.0     77.8     53.4          return cls(M, MODE_O if connected else MODE_I, x_shift, y_shift, True)

Total time: 3.29178 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: DiscreteDisk.points_list at line 314

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   314                                               def points_list(self, types: str = 'IB') -> list[Coordinate]:
   315                                                   # Vectorized version - znacznie szybsza dla dużych obszarów
   316    148873    1120548.0      7.5      3.4          if types == 'I':
   317    148873    5794503.0     38.9     17.6              mask = (self.data == MODE_I) 
   318                                                   elif types == 'B':
   319                                                       mask = (self.data == MODE_B) 
   320                                                   elif types == 'IB':
   321                                                       mask = (self.data == MODE_I) | (self.data == MODE_B)
   322                                                   else:
   323                                                       raise ValueError(f'Not supported types: {types}')
   324                                                   
   325    148873   14030232.0     94.2     42.6          ys, xs = np.nonzero(mask)
   326    148873    1299124.0      8.7      3.9          if len(ys) == 0:
   327    123279     901987.0      7.3      2.7              return []
   328                                                       
   329                                                   # Vectorized coordinate creation
   330     25594     854061.0     33.4      2.6          x_coords = xs + self.x
   331     25594     575647.0     22.5      1.7          y_coords = ys + self.y  
   332     25594    1191833.0     46.6      3.6          values = self.data[ys, xs]
   333                                                   
   334                                                   # List comprehension - szybsze niż pętla for
   335     25594    7149830.0    279.4     21.7          return [Coordinate(x_coords[i], y_coords[i], values[i]) for i in range(len(ys))]

Total time: 7.12197 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: create_area_by_join at line 496

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   496                                           def create_area_by_join(a: DiscreteDisk, b: DiscreteDisk) -> DiscreteDisk:
   497                                               """Join area, increase shape if need."""
   498                                           
   499    182118    1997032.0     11.0      2.8      DiscreteDisk.operation_disk_counter += 1
   500                                           
   501    182118    1751464.0      9.6      2.5      ah, aw = a.data.shape
   502    182118    1405658.0      7.7      2.0      bh, bw = b.data.shape
   503                                               
   504                                               # Basic operation, result is overlap region
   505    182118    2002525.0     11.0      2.8      min_x = max(a.x     , b.x     )
   506    182118    1698961.0      9.3      2.4      min_y = max(a.y     , b.y     )
   507    182118    2242678.0     12.3      3.1      max_x = min(a.x + aw, b.x + bw)
   508    182118    1944613.0     10.7      2.7      max_y = min(a.y + ah, b.y + bh)
   509                                           
   510    182118    1326744.0      7.3      1.9      w = max_x - min_x
   511    182118    1291243.0      7.1      1.8      h = max_y - min_y
   512                                           
   513    182118    1609499.0      8.8      2.3      if w > 0 and h > 0:
   514    182118    1453796.0      8.0      2.0          ax = min_x - a.x
   515    182118    1412443.0      7.8      2.0          ay = min_y - a.y
   516    182118    1381859.0      7.6      1.9          bx = min_x - b.x
   517    182118    1404143.0      7.7      2.0          by = min_y - b.y
   518                                                   
   519                                                   # Optymalizacja: in-place operacja zamiast TBL_AND indexing
   520    182118    3108824.0     17.1      4.4          asub = a.data[ay:ay+h, ax:ax+w]
   521    182118    2441685.0     13.4      3.4          bsub = b.data[by:by+h, bx:bx+w]
   522    182118    3328519.0     18.3      4.7          M = asub.copy()  # Kopia dla zachowania oryginalnych danych
   523    182118    8205745.0     45.1     11.5          np.minimum(M, bsub, out=M)  # in-place AND operation - szybsze niż TBL_AND[asub, bsub]
   524                                               else:
   525                                                   M = DISK_NONE
   526                                           
   527    182118    1854955.0     10.2      2.6      if a.rest == MODE_O and b.rest == MODE_O:
   528                                                   # Both Outer
   529     70917     540171.0      7.6      0.8          if M is DISK_NONE:
   530                                                       return DISK_OUTER
   531                                                   else:
   532     70917    5808928.0     81.9      8.2              result = DiscreteDisk(M, MODE_O, min_x, min_y, False)
   533     70917     528368.0      7.5      0.7              if opts.crop:
   534                                                           return result.crop()
   535     70917     490540.0      6.9      0.7              return result
   536    111201     948183.0      8.5      1.3      elif a.rest == MODE_O or b.rest == MODE_O:
   537                                                   # One Outer other Inner
   538    111201     785847.0      7.1      1.1          if M is DISK_NONE:
   539                                                       # Not overlapping, return the connected disk
   540                                                       c = a if a.rest == MODE_O else b
   541                                                       return c
   542                                                   else:
   543    111201     966229.0      8.7      1.4              c = a if a.rest == MODE_O else b
   544    111201     910031.0      8.2      1.3              cx = min_x - c.x
   545    111201     869397.0      7.8      1.2              cy = min_y - c.y
   546    111201    1697569.0     15.3      2.4              OM = c.data.copy()
   547    111201    5038038.0     45.3      7.1              np.copyto(OM[cy:cy+h, cx:cx+w], M)
   548    111201    9138228.0     82.2     12.8              result = DiscreteDisk(OM, MODE_O, c.x, c.y, False)
   549    111201     846730.0      7.6      1.2              if opts.crop:
   550                                                           return result.crop()
   551    111201     789025.0      7.1      1.1              return result
   552                                               else:
   553                                                   # Both Inner
   554                                                   min_x_oo = min(a.x     , b.x     )
   555                                                   min_y_oo = min(a.y     , b.y     )
   556                                                   max_x_oo = max(a.x + aw, b.x + bw)
   557                                                   max_y_oo = max(a.y + ah, b.y + bh)
   558                                           
   559                                                   w_oo = max_x_oo - min_x_oo
   560                                                   h_oo = max_y_oo - min_y_oo
   561                                                   
   562                                                   MOO = np.full((h_oo, w_oo), MODE_I, dtype=np.uint8)
   563                                           
   564                                                   ax_oo = a.x - min_x_oo
   565                                                   ay_oo = a.y - min_y_oo
   566                                                   np.copyto(MOO[ay_oo:ay_oo+ah, ax_oo:ax_oo+aw], a.data)
   567                                           
   568                                                   bx_oo = b.x - min_x_oo
   569                                                   by_oo = b.y - min_y_oo
   570                                                   np.copyto(MOO[by_oo:by_oo+bh, bx_oo:bx_oo+bw], b.data)
   571                                           
   572                                                   if M is not DISK_NONE:
   573                                                       x_oo = min_x - min_x_oo
   574                                                       y_oo = min_y - min_y_oo
   575                                                       np.copyto(MOO[y_oo:y_oo+h, x_oo:x_oo+w], M)
   576                                           
   577                                                   result = DiscreteDisk(MOO, MODE_I, min_x_oo, min_y_oo, False)
   578                                                   if opts.crop:
   579                                                       return result.crop()
   580                                                   return result

Total time: 25.783 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\profile\profile_udg.py
Function: run_d at line 28

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    28                                           def run_d():
    29                                               # py udg.py -g GUzvvk -u 10 -d sq_center -o "P"
    30         1        204.0    204.0      0.0      discrete_disk.set_disk_mode('sq_center')
    31         1      12650.0  12650.0      0.0      nxg = Graph6Converter.g6_to_graph('GUzvvk')
    32         1      23643.0  23643.0      0.0      g = udg.Graph(nxg)
    33         1         53.0     53.0      0.0      g.set_unit(10)
    34         1         11.0     11.0      0.0      g.order_mode = 'P'
    35         1  257793907.0 2.58e+08    100.0      g.udg_recognition()

Total time: 0.311397 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.set_coordinate at line 175

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   175                                               def set_coordinate(self, v: int, x: int, y: int, mode: np.uint8 = MODE_U):
   176                                                   """Set coordinates for vertex ``v``."""
   177    148874    1064666.0      7.2     34.2          v = self.coordinates[v]
   178    148874    1064834.0      7.2     34.2          v.x, v.y, v.mode = x, y, mode
   179    148874     984473.0      6.6     31.6          return self

Total time: 0.234468 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.clear_previous_area at line 181

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   181                                               def clear_previous_area(self, order_index: int):
   182    148874    2344682.0     15.7    100.0          for row in self.prev_area_by_v_o: row[order_index] = False

Total time: 0.221748 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.set_iteration_index at line 188

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   188                                               def set_iteration_index(self, v: int, index: int):
   189    148874    1221239.0      8.2     55.1          c = self.iterations[v].point_iter = index
   190    148874     996239.0      6.7     44.9          return self

Total time: 25.7794 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.udg_recognition at line 387

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   387                                               def udg_recognition(self):
   388         1         28.0     28.0      0.0          self.start_time = time.time()
   389         1          9.0      9.0      0.0          self.last_verbose_time = self.start_time
   390         1          9.0      9.0      0.0          self.last_progress_time = self.start_time
   391                                           
   392         1       1325.0   1325.0      0.0          if not self.is_connected():
   393                                                       self.stop_time = time.time()
   394                                                       if self.log_level >= LOG_BASIC:
   395                                                           print("Graph is not connected, cannot be a UDG.")
   396                                                       return False
   397                                           
   398         1        140.0    140.0      0.0          if self.is_full():
   399                                                       self.stop_time = time.time()
   400                                                       if self.log_level >= LOG_BASIC:
   401                                                           print("Graph is full, it is a UDG.")
   402                                                       return True
   403                                                   
   404         1      81520.0  81520.0      0.0          self.apply_order()
   405                                           
   406         1         12.0     12.0      0.0          self.level = 0
   407         1          7.0      7.0      0.0          while True:
   408         1          7.0      7.0      0.0              if self.log_level >= LOG_BASIC:
   409         1         78.0     78.0      0.0                  print(f"Checking unit: {self.unit}")
   410         1  257710469.0 2.58e+08    100.0              result = self.has_discrete_realization()
   411         1          9.0      9.0      0.0              if result == YES:
   412         1         48.0     48.0      0.0                  self.stop_time = time.time()
   413         1          7.0      7.0      0.0                  return True
   414                                                       if result == NO:
   415                                                           self.stop_time = time.time()
   416                                                           return False
   417                                           
   418                                                       if self.is_limit_achieved():
   419                                                           self.stop_time = time.time()
   420                                                           if self.log_level >= LOG_BASIC:
   421                                                               print(f"Reached max unit = {self.unit}, no realization found.")
   422                                                           return False
   423                                                       
   424                                                       self.refine_granularity()
   425                                                       self.level += 1

Total time: 25.771 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.has_discrete_realization at line 482

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   482                                               def has_discrete_realization(self):
   483         1         18.0     18.0      0.0          range_modes = [True] if self.optimize_for_yes else [True, False]
   484         1          8.0      8.0      0.0          for only_I in range_modes:
   485         1          8.0      8.0      0.0              if self.log_level >= LOG_INFO:
   486                                                           print(f"  {'Inner' if only_I else 'All'}")
   487         1          6.0      6.0      0.0              count_I: int = 0
   488         1          6.0      6.0      0.0              count_B: int = 0
   489         1  257710263.0 2.58e+08    100.0              result = self.place_next_vertex(0, False, only_I, count_I, count_B)
   490         1          9.0      9.0      0.0              if result == YES:
   491         1          8.0      8.0      0.0                  return YES
   492                                                   return result

Total time: 24.5075 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.place_next_vertex at line 603

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   603                                               def place_next_vertex(self, j: int, calc_D: bool, only_I: bool, count_I: int, count_B: int):
   604    148874    1439035.0      9.7      0.6          if (j > 1) and self.order_mode.__contains__('auto'): # automatic order by checking min number of allowed points, first two should always be set ('auto' mode has no sense alone)
   605                                                       P = self.minimize_coordinates(j, only_I, count_I, count_B)
   606                                                   else:
   607    148874  202976898.0   1363.4     82.8              P = self.candidate_points(j, only_I, count_I, count_B)
   608                                           
   609    148874    1084237.0      7.3      0.4          vertex = self.order[j]
   610                                           
   611    148874    1086772.0      7.3      0.4          if self.log_level >= LOG_TRACE:
   612                                                       print(f"order[{j}]={vertex} : {len(P)} points")
   613                                           
   614    148874     974863.0      6.5      0.4          found_trigraph = False
   615                                           
   616    148874    1192559.0      8.0      0.5          if self.print_progress > 0:
   617                                                       self.set_iteration_len(vertex, len(P))
   618                                                   
   619    148874     958008.0      6.4      0.4          iter_p = -1
   620    297740    2318700.0      7.8      0.9          for p in P:
   621    148874    1006248.0      6.8      0.4              iter_p += 1
   622    148874    5639685.0     37.9      2.3              self.set_iteration_index(vertex, iter_p)
   623                                           
   624    148874    1417613.0      9.5      0.6              incr_I = 1 if p.mode == MODE_I else 0
   625    148874    1155299.0      7.8      0.5              incr_B = 1 if p.mode == MODE_B else 0
   626                                           
   627    148874    6857233.0     46.1      2.8              self.set_coordinate(vertex, p.x, p.y, p.mode)
   628    148874    5073112.0     34.1      2.1              self.clear_previous_area(j)
   629                                           
   630    148874    1232120.0      8.3      0.5              self.place_next_vertex_counter += 1
   631    148874    1096253.0      7.4      0.4              if self.collect_work_summary:
   632                                                           self.mark_place_next_vertex_process(j)
   633                                                       
   634    148874    1022060.0      6.9      0.4              if (self.print_progress > 0) and (time.time() - self.last_progress_time > self.print_progress):
   635                                                           self.last_progress_time = time.time()
   636                                                           if time.time() - self.last_verbose_time > 10:
   637                                                               self.last_verbose_time = time.time()
   638                                                               print("  placing " + self.state_info(only_I, j))
   639    148874    1062693.0      7.1      0.4              if (self.log_level >= LOG_DEBUG) or (self.log_level == LOG_WORK_ORDER):
   640                                                           print(f"vertex = {self.order[j]} already_placed = {j} coordinates = {self.print_coordinates(j)}")
   641    148874    1073713.0      7.2      0.4              if j < self.n - 1:
   642    148873    1186114.0      8.0      0.5                  result = self.place_next_vertex(j + 1, calc_D, only_I, count_I + incr_I, count_B + incr_B)
   643    148873    1047843.0      7.0      0.4                  if result == YES:
   644         7         55.0      7.9      0.0                      return YES
   645    148866     955570.0      6.4      0.4                  if result == TRIGRAPH:
   646                                                               if not only_I:
   647                                                                   return TRIGRAPH
   648                                                               if not calc_D:
   649                                                                   found_trigraph=True
   650    148866    1044364.0      7.0      0.4                  if not only_I and (result == NO):
   651                                                               if self.log_level >= LOG_DEBUG:
   652                                                                   if j < 4:
   653                                                                       print(f" unit={self.unit} level={j} forbidden at {self.state_info(only_I, j)}")
   654                                                               elif self.log_level >= LOG_TRACE:
   655                                                                   print(f" unit={self.unit} level={j} forbidden at {self.state_info(only_I, j)}")
   656                                                       else:
   657                                                           # if self.is_udg_realization():
   658         1         21.0     21.0      0.0                  if count_I + incr_I == self.n:
   659         1          6.0      6.0      0.0                      if calc_D:
   660                                                                   self.store_vertex_distances(MODE_I)
   661                                                                   self.result_I += 1
   662                                                               else:
   663         1          8.0      8.0      0.0                          return YES
   664                                                           if not only_I:
   665                                                               if calc_D:
   666                                                                   self.store_vertex_distances(MODE_B)
   667                                                                   self.result_B += 1
   668                                                               else:
   669                                                                   return TRIGRAPH
   670                                                           if not calc_D:
   671                                                               found_trigraph = True
   672                                                   
   673    148866     964988.0      6.5      0.4          if not found_trigraph:
   674    148866    1208461.0      8.1      0.5              return TRIGRAPH if self.optimize_for_yes else NO
   675                                           
   676                                                   return TRIGRAPH

Total time: 19.9175 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.candidate_points at line 711

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   711                                               def candidate_points(self, j: int, only_I: bool, count_I: int, count_B: int) -> list[Coordinate]:
   712    148874  197155984.0   1324.3     99.0          P = self.candidate_points_without_order(j, only_I, count_I, count_B)
   713                                           
   714                                                   # Ultra-fast pre-compiled sorting - eliminuje if-elif chain
   715    148874    1020475.0      6.9      0.5          if self._point_sort_key is not None:
   716                                                       P.sort(key=self._point_sort_key)
   717                                                   # else: keep original order (no sorting needed)
   718                                           
   719    148874     998303.0      6.7      0.5          return P

Total time: 18.7239 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.candidate_points_without_order at line 736

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   736                                               def candidate_points_without_order(self, j: int, only_I: bool, count_I: int, count_B: int) -> list[Coordinate]:
   737    148874     982509.0      6.6      0.5          if j == 0:
   738         1          7.0      7.0      0.0              P = []
   739         1         95.0     95.0      0.0              P.append(Coordinate(x = 0, y = 0, mode = MODE_I))
   740         1          6.0      6.0      0.0              return P
   741    148873     971583.0      6.5      0.5          if j == 1:
   742         1         59.0     59.0      0.0              """ Previous is 0, so coordinate is equal (0,0) """
   743         1      13755.0  13755.0      0.0              area = self.create_area_for_next_vertex_join(0, 0, self.order[0], self.order[1], True)
   744         1          9.0      9.0      0.0              if self.limit_points:
   745         1      11016.0  11016.0      0.0                  P = [p for p in area.points_list(types = ('I' if only_I else 'IB')) if p.x == 0 and p.y >= 0] # for hex only y axis is unit one
   746                                                       else:
   747                                                           P = [p for p in area.points_list(types = ('I' if only_I else 'IB')) if p.x >= 0 and p.y >= 0]
   748                                           
   749         1         12.0     12.0      0.0              if self.check_distance:
   750                                                           if self.check_distance_iteration >= len(P) - 1:
   751                                                               # This is the last index, handle accordingly
   752                                                               p = P[-1]  # Get the last element
   753                                                               self.check_distance = False  # Stop further iterations
   754                                                           else:
   755                                                               p = P[self.check_distance_iteration]
   756                                                           P = []
   757                                                           P.append(p)
   758                                                       
   759         1          6.0      6.0      0.0              return P
   760                                           
   761    148872     949579.0      6.4      0.5          i = j - 2
   762    182123    1378470.0      7.6      0.7          while i >= 0 and self.prev_area_by_v_o[self.order[j]][i] is False:
   763     33251     211390.0      6.4      0.1              i -= 1
   764                                                   
   765    330995    3040628.0      9.2      1.6          for k in range(i+1, j):
   766    182123    1310577.0      7.2      0.7              coord_v_order_k = self.coordinates[self.order[k]]
   767                                                       # For first iteration area have to limit points in distance range - so force_limit_negative_distance set to true
   768    182123   44207543.0    242.7     23.6              area = self.create_area_for_next_vertex_join(coord_v_order_k.x, coord_v_order_k.y, self.order[j], self.order[k], k == 0)
   769    182123    1218130.0      6.7      0.7              if k > 0:
   770    182117    1377449.0      7.6      0.7                  prev_area = self.prev_area_by_v_o[self.order[j]][k-1]
   771    182117   89182898.0    489.7     47.6                  area = create_area_by_join(prev_area, area) 
   772    182123    1522881.0      8.4      0.8              self.prev_area_by_v_o[self.order[j]][k] = area
   773                                           
   774    148872     951459.0      6.4      0.5          """For limit points return only positive y coordinates for second vertex"""
   775    148872    1004930.0      6.8      0.5          if j == 2:
   776        10         73.0      7.3      0.0              if self.limit_points:
   777        10      30427.0   3042.7      0.0                  P = [p for p in area.points_list(types = ('I' if only_I else 'IB')) if p.x >= 0]
   778        10         82.0      8.2      0.0                  return P
   779                                                       else:
   780                                                           return area.points_list(types = ('I' if only_I else 'IB'))
   781                                                   else: 
   782    148862   38873071.0    261.1     20.8              return area.points_list(types = ('I' if only_I else 'IB'))

Total time: 3.78601 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.create_area_for_next_vertex_join at line 784

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   784                                               def create_area_for_next_vertex_join(self, x:int, y:int, u: int, v: int, force_limit_negative_distance: bool = False) -> DiscreteDisk:
   785    182124    1368571.0      7.5      3.6          distance = self.vertex_edge_distance[u][v]
   786    182124    1217757.0      6.7      3.2          if distance == 1:
   787     70923   12852979.0    181.2     33.9              area = DiscreteDisk.disk(self.unit, x, y, connected = 1)          
   788                                                   else:
   789    111201   20235103.0    182.0     53.4              area = DiscreteDisk.disk(self.unit, x, y, connected = 0)
   790    111201     824217.0      7.4      2.2              if force_limit_negative_distance or self.limit_negative_distances:
   791         1      42070.0  42070.0      0.1                  area = create_area_by_join(area, DiscreteDisk.disk(self.unit * distance, x, y, connected = 1))
   792    182124    1319357.0      7.2      3.5          return area

