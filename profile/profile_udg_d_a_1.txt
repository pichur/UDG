Checking unit: 10
Show only functions ≥ 0.100 s
Timer unit: 1e-07 s

Total time: 6.56801 s

Could not find file <string>
Are you sure you are running this program from the same directory
that you ran the profiler from?
Continuing without the function's contents.

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     2                                           
     3   3094790   21726437.0      7.0     33.1  
     4   3094790   21148629.0      6.8     32.2  
     5   3094782   22804996.0      7.4     34.7  

Total time: 0.331382 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: _get_from_disk_cache at line 231

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   231                                           def _get_from_disk_cache(radius: int, connected: int = 1) -> np.ndarray:
   232    175142    1528578.0      8.7     46.1      if radius not in _disk_cache:
   233         2         26.0     13.0      0.0          if opts.disk_mode== 'sq_center':
   234         2      59615.0  29807.5      1.8              _create_disk_sq_center(radius, connected)
   235                                                   elif opts.disk_mode == 'sq_border':
   236                                                       _create_disk_sq_border(radius, connected)
   237                                                   elif opts.disk_mode == 'hex_center':
   238                                                       _create_disk_hex_center(radius, connected)
   239                                                   else:
   240                                                       raise ValueError(f'Not supported disk mode: {opts.disk_mode}')
   241                                               
   242    175142    1725600.0      9.9     52.1      return _disk_cache[radius][connected]

Total time: 1.48776 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: DiscreteDisk.__init__ at line 278

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   278                                               def __init__(self, data: np.ndarray, rest: np.uint8, x: int, y: int, _shared: bool = False):
   279    349986    3447344.0      9.8     23.2          self.data = data
   280    349986    2903054.0      8.3     19.5          self.rest = rest
   281    349986    2714773.0      7.8     18.2          self.x = x
   282    349986    2685075.0      7.7     18.0          self.y = y
   283    349986    3127336.0      8.9     21.0          self._shared = _shared

Total time: 2.84384 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: DiscreteDisk.disk at line 301

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   301                                               @classmethod
   302                                               def disk(cls, radius: int = 4, x: int = 0, y: int = 0, connected: int = 1) -> "DiscreteDisk":
   303    175142    8433066.0     48.1     29.7          M = _get_from_disk_cache(radius, connected)
   304                                           
   305    175142    1554965.0      8.9      5.5          if opts.disk_mode == 'hex_center':
   306                                                       x_shift = x - _hex_x_range(radius)
   307                                                       y_shift = y - 2 * radius
   308                                                   else:
   309    175142    1827035.0     10.4      6.4              x_shift = x - radius
   310    175142    1437864.0      8.2      5.1              y_shift = y - radius
   311                                                   
   312    175142   15185453.0     86.7     53.4          return cls(M, MODE_O if connected else MODE_I, x_shift, y_shift, True)

Total time: 18.2733 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: DiscreteDisk.points_list at line 314

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   314                                               def points_list(self, types: str = 'IB') -> list[Coordinate]:
   315                                                   # Vectorized version - znacznie szybsza dla dużych obszarów
   316    175135    1416950.0      8.1      0.8          if types == 'I':
   317    175135    7562200.0     43.2      4.1              mask = (self.data == MODE_I) 
   318                                                   elif types == 'B':
   319                                                       mask = (self.data == MODE_B) 
   320                                                   elif types == 'IB':
   321                                                       mask = (self.data == MODE_I) | (self.data == MODE_B)
   322                                                   else:
   323                                                       raise ValueError(f'Not supported types: {types}')
   324                                                   
   325    175135   19037541.0    108.7     10.4          ys, xs = np.nonzero(mask)
   326    175135    1729960.0      9.9      0.9          if len(ys) == 0:
   327     67602     558168.0      8.3      0.3              return []
   328                                                       
   329                                                   # Vectorized coordinate creation
   330    107533    3659182.0     34.0      2.0          x_coords = xs + self.x
   331    107533    2571580.0     23.9      1.4          y_coords = ys + self.y  
   332    107533    4999924.0     46.5      2.7          values = self.data[ys, xs]
   333                                                   
   334                                                   # List comprehension - szybsze niż pętla for
   335    107533  141197142.0   1313.1     77.3          return [Coordinate(x_coords[i], y_coords[i], values[i]) for i in range(len(ys))]

Total time: 6.99702 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: create_area_by_join at line 496

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   496                                           def create_area_by_join(a: DiscreteDisk, b: DiscreteDisk) -> DiscreteDisk:
   497                                               """Join area, increase shape if need."""
   498                                           
   499    175135    2111250.0     12.1      3.0      DiscreteDisk.operation_disk_counter += 1
   500                                           
   501    175135    1896500.0     10.8      2.7      ah, aw = a.data.shape
   502    175135    1500399.0      8.6      2.1      bh, bw = b.data.shape
   503                                               
   504                                               # Basic operation, result is overlap region
   505    175135    2152084.0     12.3      3.1      min_x = max(a.x     , b.x     )
   506    175135    1686902.0      9.6      2.4      min_y = max(a.y     , b.y     )
   507    175135    2300477.0     13.1      3.3      max_x = min(a.x + aw, b.x + bw)
   508    175135    1981528.0     11.3      2.8      max_y = min(a.y + ah, b.y + bh)
   509                                           
   510    175135    1510007.0      8.6      2.2      w = max_x - min_x
   511    175135    1414755.0      8.1      2.0      h = max_y - min_y
   512                                           
   513    175135    1796257.0     10.3      2.6      if w > 0 and h > 0:
   514    174844    1581580.0      9.0      2.3          ax = min_x - a.x
   515    174844    1558842.0      8.9      2.2          ay = min_y - a.y
   516    174844    1500622.0      8.6      2.1          bx = min_x - b.x
   517    174844    1433724.0      8.2      2.0          by = min_y - b.y
   518                                                   
   519                                                   # Optymalizacja: in-place operacja zamiast TBL_AND indexing
   520    174844    3431336.0     19.6      4.9          asub = a.data[ay:ay+h, ax:ax+w]
   521    174844    2603613.0     14.9      3.7          bsub = b.data[by:by+h, bx:bx+w]
   522    174844    3947769.0     22.6      5.6          M = asub.copy()  # Kopia dla zachowania oryginalnych danych
   523    174844    9090274.0     52.0     13.0          np.minimum(M, bsub, out=M)  # in-place AND operation - szybsze niż TBL_AND[asub, bsub]
   524                                               else:
   525       291       1777.0      6.1      0.0          M = DISK_NONE
   526                                           
   527    175135    1985559.0     11.3      2.8      if a.rest == MODE_O and b.rest == MODE_O:
   528                                                   # Both Outer
   529    126570    1009951.0      8.0      1.4          if M is DISK_NONE:
   530       291       1958.0      6.7      0.0              return DISK_OUTER
   531                                                   else:
   532    126279   10664438.0     84.5     15.2              result = DiscreteDisk(M, MODE_O, min_x, min_y, False)
   533    126279    1073093.0      8.5      1.5              if opts.crop:
   534                                                           return result.crop()
   535    126279     990543.0      7.8      1.4              return result
   536     48565     424365.0      8.7      0.6      elif a.rest == MODE_O or b.rest == MODE_O:
   537                                                   # One Outer other Inner
   538     48565     383442.0      7.9      0.5          if M is DISK_NONE:
   539                                                       # Not overlapping, return the connected disk
   540                                                       c = a if a.rest == MODE_O else b
   541                                                       return c
   542                                                   else:
   543     48565     444648.0      9.2      0.6              c = a if a.rest == MODE_O else b
   544     48565     439782.0      9.1      0.6              cx = min_x - c.x
   545     48565     414780.0      8.5      0.6              cy = min_y - c.y
   546     48565     881210.0     18.1      1.3              OM = c.data.copy()
   547     48565    2666988.0     54.9      3.8              np.copyto(OM[cy:cy+h, cx:cx+w], M)
   548     48565    4264060.0     87.8      6.1              result = DiscreteDisk(OM, MODE_O, c.x, c.y, False)
   549     48565     437031.0      9.0      0.6              if opts.crop:
   550                                                           return result.crop()
   551     48565     388613.0      8.0      0.6              return result
   552                                               else:
   553                                                   # Both Inner
   554                                                   min_x_oo = min(a.x     , b.x     )
   555                                                   min_y_oo = min(a.y     , b.y     )
   556                                                   max_x_oo = max(a.x + aw, b.x + bw)
   557                                                   max_y_oo = max(a.y + ah, b.y + bh)
   558                                           
   559                                                   w_oo = max_x_oo - min_x_oo
   560                                                   h_oo = max_y_oo - min_y_oo
   561                                                   
   562                                                   MOO = np.full((h_oo, w_oo), MODE_I, dtype=np.uint8)
   563                                           
   564                                                   ax_oo = a.x - min_x_oo
   565                                                   ay_oo = a.y - min_y_oo
   566                                                   np.copyto(MOO[ay_oo:ay_oo+ah, ax_oo:ax_oo+aw], a.data)
   567                                           
   568                                                   bx_oo = b.x - min_x_oo
   569                                                   by_oo = b.y - min_y_oo
   570                                                   np.copyto(MOO[by_oo:by_oo+bh, bx_oo:bx_oo+bw], b.data)
   571                                           
   572                                                   if M is not DISK_NONE:
   573                                                       x_oo = min_x - min_x_oo
   574                                                       y_oo = min_y - min_y_oo
   575                                                       np.copyto(MOO[y_oo:y_oo+h, x_oo:x_oo+w], M)
   576                                           
   577                                                   result = DiscreteDisk(MOO, MODE_I, min_x_oo, min_y_oo, False)
   578                                                   if opts.crop:
   579                                                       return result.crop()
   580                                                   return result

Total time: 42.3409 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\profile\profile_udg.py
Function: run_d at line 28

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    28                                           def run_d():
    29                                               # py udg.py -g GUzvvk -u 10 -d sq_center -o "P"
    30         1        277.0    277.0      0.0      discrete_disk.set_disk_mode('sq_center')
    31         1      18674.0  18674.0      0.0      nxg = Graph6Converter.g6_to_graph('GUzvvk')
    32         1      32480.0  32480.0      0.0      g = udg.Graph(nxg)
    33         1         61.0     61.0      0.0      g.set_unit(10)
    34         1         11.0     11.0      0.0      g.order_mode = 'P_auto'
    35         1  423357278.0 4.23e+08    100.0      g.udg_recognition()

Total time: 0.135855 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.set_coordinate at line 175

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   175                                               def set_coordinate(self, v: int, x: int, y: int, mode: np.uint8 = MODE_U):
   176                                                   """Set coordinates for vertex ``v``."""
   177     58544     457692.0      7.8     33.7          v = self.coordinates[v]
   178     58544     473271.0      8.1     34.8          v.x, v.y, v.mode = x, y, mode
   179     58544     427592.0      7.3     31.5          return self

Total time: 0.125468 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.clear_previous_area at line 181

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   181                                               def clear_previous_area(self, order_index: int):
   182     58544    1254678.0     21.4    100.0          for row in self.prev_area_by_v_o: row[order_index] = False

Total time: 42.3357 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.udg_recognition at line 387

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   387                                               def udg_recognition(self):
   388         1         32.0     32.0      0.0          self.start_time = time.time()
   389         1         12.0     12.0      0.0          self.last_verbose_time = self.start_time
   390         1         10.0     10.0      0.0          self.last_progress_time = self.start_time
   391                                           
   392         1       1567.0   1567.0      0.0          if not self.is_connected():
   393                                                       self.stop_time = time.time()
   394                                                       if self.log_level >= LOG_BASIC:
   395                                                           print("Graph is not connected, cannot be a UDG.")
   396                                                       return False
   397                                           
   398         1        154.0    154.0      0.0          if self.is_full():
   399                                                       self.stop_time = time.time()
   400                                                       if self.log_level >= LOG_BASIC:
   401                                                           print("Graph is full, it is a UDG.")
   402                                                       return True
   403                                                   
   404         1      83270.0  83270.0      0.0          self.apply_order()
   405                                           
   406         1         11.0     11.0      0.0          self.level = 0
   407         1          7.0      7.0      0.0          while True:
   408         1          8.0      8.0      0.0              if self.log_level >= LOG_BASIC:
   409         1         75.0     75.0      0.0                  print(f"Checking unit: {self.unit}")
   410         1  423271780.0 4.23e+08    100.0              result = self.has_discrete_realization()
   411         1         12.0     12.0      0.0              if result == YES:
   412         1         64.0     64.0      0.0                  self.stop_time = time.time()
   413         1          8.0      8.0      0.0                  return True
   414                                                       if result == NO:
   415                                                           self.stop_time = time.time()
   416                                                           return False
   417                                           
   418                                                       if self.is_limit_achieved():
   419                                                           self.stop_time = time.time()
   420                                                           if self.log_level >= LOG_BASIC:
   421                                                               print(f"Reached max unit = {self.unit}, no realization found.")
   422                                                           return False
   423                                                       
   424                                                       self.refine_granularity()
   425                                                       self.level += 1

Total time: 42.3272 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.has_discrete_realization at line 482

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   482                                               def has_discrete_realization(self):
   483         1         15.0     15.0      0.0          range_modes = [True] if self.optimize_for_yes else [True, False]
   484         1          8.0      8.0      0.0          for only_I in range_modes:
   485         1          9.0      9.0      0.0              if self.log_level >= LOG_INFO:
   486                                                           print(f"  {'Inner' if only_I else 'All'}")
   487         1          7.0      7.0      0.0              count_I: int = 0
   488         1          7.0      7.0      0.0              count_B: int = 0
   489         1  423271571.0 4.23e+08    100.0              result = self.place_next_vertex(0, False, only_I, count_I, count_B)
   490         1          9.0      9.0      0.0              if result == YES:
   491         1          8.0      8.0      0.0                  return YES
   492                                                   return result

Total time: 38.7349 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.minimize_coordinates at line 573

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   573                                               def minimize_coordinates(self, j: int, only_I: bool, count_I: int, count_B: int) -> list[Coordinate]:
   574                                                   # Find the unplaced vertex with the smallest number of candidate points
   575     58542     956476.0     16.3      0.2          min_candidates = float('inf')
   576     58542     423644.0      7.2      0.1          best_vertex = None
   577     58542     398466.0      6.8      0.1          best_P = None
   578                                           
   579    526878    4442567.0      8.4      1.1          for v in range(self.n):
   580                                                       # Skip vertices that are already placed in order
   581    468336    4893504.0     10.4      1.3              if v in self.order[:j]:
   582    293202    2049632.0      7.0      0.5                  continue
   583                                                       
   584                                                       # Temporarily set this vertex as the next one to get candidate points
   585    175134    1358986.0      7.8      0.4              self.order[j] = v
   586                                                       
   587                                                       # Get candidate points for this vertex
   588    175134  364198264.0   2079.5     94.0              curr_P = self.candidate_points(j, only_I, count_I, count_B)
   589    175134    1536858.0      8.8      0.4              num_candidates = len(curr_P)
   590                                                       
   591    175134    1399762.0      8.0      0.4              if self.log_level > LOG_TRACE:
   592                                                           print(f"  check order {j}={v} : {num_candidates}")
   593                                           
   594                                                       # Check if this is the best option so far
   595    175134    1492229.0      8.5      0.4              if num_candidates < min_candidates:
   596     98133     739588.0      7.5      0.2                  min_candidates = num_candidates
   597     98133     690457.0      7.0      0.2                  best_vertex = v
   598     98133    1846590.0     18.8      0.5                  best_P = curr_P
   599                                                   # Set the best vertex at position j and use its candidate points
   600     58542     456133.0      7.8      0.1          self.order[j] = best_vertex
   601     58542     465429.0      8.0      0.1          return best_P

Total time: 41.7714 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.place_next_vertex at line 603

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   603                                               def place_next_vertex(self, j: int, calc_D: bool, only_I: bool, count_I: int, count_B: int):
   604     58544     749608.0     12.8      0.2          if (j > 1) and self.order_mode.__contains__('auto'): # automatic order by checking min number of allowed points, first two should always be set ('auto' mode has no sense alone)
   605     58542  398484236.0   6806.8     95.4              P = self.minimize_coordinates(j, only_I, count_I, count_B)
   606                                                   else:
   607         2      27287.0  13643.5      0.0              P = self.candidate_points(j, only_I, count_I, count_B)
   608                                           
   609     58544     485198.0      8.3      0.1          vertex = self.order[j]
   610                                           
   611     58544     445644.0      7.6      0.1          if self.log_level >= LOG_TRACE:
   612                                                       print(f"order[{j}]={vertex} : {len(P)} points")
   613                                           
   614     58544     423735.0      7.2      0.1          found_trigraph = False
   615                                           
   616     58544     541910.0      9.3      0.1          if self.print_progress > 0:
   617                                                       self.set_iteration_len(vertex, len(P))
   618                                                   
   619     58544     415349.0      7.1      0.1          iter_p = -1
   620    117080    1063790.0      9.1      0.3          for p in P:
   621     58544     438852.0      7.5      0.1              iter_p += 1
   622     58544    2519272.0     43.0      0.6              self.set_iteration_index(vertex, iter_p)
   623                                           
   624     58544     673150.0     11.5      0.2              incr_I = 1 if p.mode == MODE_I else 0
   625     58544     520118.0      8.9      0.1              incr_B = 1 if p.mode == MODE_B else 0
   626                                           
   627     58544    3030045.0     51.8      0.7              self.set_coordinate(vertex, p.x, p.y, p.mode)
   628     58544    2502317.0     42.7      0.6              self.clear_previous_area(j)
   629                                           
   630     58544     576014.0      9.8      0.1              self.place_next_vertex_counter += 1
   631     58544     496450.0      8.5      0.1              if self.collect_work_summary:
   632                                                           self.mark_place_next_vertex_process(j)
   633                                                       
   634     58544     453313.0      7.7      0.1              if (self.print_progress > 0) and (time.time() - self.last_progress_time > self.print_progress):
   635                                                           self.last_progress_time = time.time()
   636                                                           if time.time() - self.last_verbose_time > 10:
   637                                                               self.last_verbose_time = time.time()
   638                                                               print("  placing " + self.state_info(only_I, j))
   639     58544     470486.0      8.0      0.1              if (self.log_level >= LOG_DEBUG) or (self.log_level == LOG_WORK_ORDER):
   640                                                           print(f"vertex = {self.order[j]} already_placed = {j} coordinates = {self.print_coordinates(j)}")
   641     58544     475321.0      8.1      0.1              if j < self.n - 1:
   642     58543     544815.0      9.3      0.1                  result = self.place_next_vertex(j + 1, calc_D, only_I, count_I + incr_I, count_B + incr_B)
   643     58543     479175.0      8.2      0.1                  if result == YES:
   644         7         70.0     10.0      0.0                      return YES
   645     58536     433080.0      7.4      0.1                  if result == TRIGRAPH:
   646                                                               if not only_I:
   647                                                                   return TRIGRAPH
   648                                                               if not calc_D:
   649                                                                   found_trigraph=True
   650     58536     478671.0      8.2      0.1                  if not only_I and (result == NO):
   651                                                               if self.log_level >= LOG_DEBUG:
   652                                                                   if j < 4:
   653                                                                       print(f" unit={self.unit} level={j} forbidden at {self.state_info(only_I, j)}")
   654                                                               elif self.log_level >= LOG_TRACE:
   655                                                                   print(f" unit={self.unit} level={j} forbidden at {self.state_info(only_I, j)}")
   656                                                       else:
   657                                                           # if self.is_udg_realization():
   658         1         30.0     30.0      0.0                  if count_I + incr_I == self.n:
   659         1          8.0      8.0      0.0                      if calc_D:
   660                                                                   self.store_vertex_distances(MODE_I)
   661                                                                   self.result_I += 1
   662                                                               else:
   663         1         10.0     10.0      0.0                          return YES
   664                                                           if not only_I:
   665                                                               if calc_D:
   666                                                                   self.store_vertex_distances(MODE_B)
   667                                                                   self.result_B += 1
   668                                                               else:
   669                                                                   return TRIGRAPH
   670                                                           if not calc_D:
   671                                                               found_trigraph = True
   672                                                   
   673     58536     428336.0      7.3      0.1          if not found_trigraph:
   674     58536     557685.0      9.5      0.1              return TRIGRAPH if self.optimize_for_yes else NO
   675                                           
   676                                                   return TRIGRAPH

Total time: 35.8111 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.candidate_points at line 711

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   711                                               def candidate_points(self, j: int, only_I: bool, count_I: int, count_B: int) -> list[Coordinate]:
   712    175136  355440973.0   2029.5     99.3          P = self.candidate_points_without_order(j, only_I, count_I, count_B)
   713                                           
   714                                                   # Ultra-fast pre-compiled sorting - eliminuje if-elif chain
   715    175136    1353979.0      7.7      0.4          if self._point_sort_key is not None:
   716                                                       P.sort(key=self._point_sort_key)
   717                                                   # else: keep original order (no sorting needed)
   718                                           
   719    175136    1315741.0      7.5      0.4          return P

Total time: 34.3615 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.candidate_points_without_order at line 736

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   736                                               def candidate_points_without_order(self, j: int, only_I: bool, count_I: int, count_B: int) -> list[Coordinate]:
   737    175136    1317993.0      7.5      0.4          if j == 0:
   738         1          7.0      7.0      0.0              P = []
   739         1         93.0     93.0      0.0              P.append(Coordinate(x = 0, y = 0, mode = MODE_I))
   740         1          7.0      7.0      0.0              return P
   741    175135    1313834.0      7.5      0.4          if j == 1:
   742         1          7.0      7.0      0.0              """ Previous is 0, so coordinate is equal (0,0) """
   743         1      15047.0  15047.0      0.0              area = self.create_area_for_next_vertex_join(0, 0, self.order[0], self.order[1], True)
   744         1         10.0     10.0      0.0              if self.limit_points:
   745         1      11502.0  11502.0      0.0                  P = [p for p in area.points_list(types = ('I' if only_I else 'IB')) if p.x == 0 and p.y >= 0] # for hex only y axis is unit one
   746                                                       else:
   747                                                           P = [p for p in area.points_list(types = ('I' if only_I else 'IB')) if p.x >= 0 and p.y >= 0]
   748                                           
   749         1         13.0     13.0      0.0              if self.check_distance:
   750                                                           if self.check_distance_iteration >= len(P) - 1:
   751                                                               # This is the last index, handle accordingly
   752                                                               p = P[-1]  # Get the last element
   753                                                               self.check_distance = False  # Stop further iterations
   754                                                           else:
   755                                                               p = P[self.check_distance_iteration]
   756                                                           P = []
   757                                                           P.append(p)
   758                                                       
   759         1          7.0      7.0      0.0              return P
   760                                           
   761    175134    1302567.0      7.4      0.4          i = j - 2
   762    175140    1550394.0      8.9      0.5          while i >= 0 and self.prev_area_by_v_o[self.order[j]][i] is False:
   763         6         47.0      7.8      0.0              i -= 1
   764                                                   
   765    350274    3448376.0      9.8      1.0          for k in range(i+1, j):
   766    175140    1363875.0      7.8      0.4              coord_v_order_k = self.coordinates[self.order[k]]
   767                                                       # For first iteration area have to limit points in distance range - so force_limit_negative_distance set to true
   768    175140   46519561.0    265.6     13.5              area = self.create_area_for_next_vertex_join(coord_v_order_k.x, coord_v_order_k.y, self.order[j], self.order[k], k == 0)
   769    175140    1301417.0      7.4      0.4              if k > 0:
   770    175134    1457509.0      8.3      0.4                  prev_area = self.prev_area_by_v_o[self.order[j]][k-1]
   771    175134   88313667.0    504.3     25.7                  area = create_area_by_join(prev_area, area) 
   772    175140    1626742.0      9.3      0.5              self.prev_area_by_v_o[self.order[j]][k] = area
   773                                           
   774    175134    1217121.0      6.9      0.4          """For limit points return only positive y coordinates for second vertex"""
   775    175134    1288176.0      7.4      0.4          if j == 2:
   776        60        413.0      6.9      0.0              if self.limit_points:
   777        60     410055.0   6834.2      0.1                  P = [p for p in area.points_list(types = ('I' if only_I else 'IB')) if p.x >= 0]
   778        60        482.0      8.0      0.0                  return P
   779                                                       else:
   780                                                           return area.points_list(types = ('I' if only_I else 'IB'))
   781                                                   else: 
   782    175074  191155854.0   1091.9     55.6              return area.points_list(types = ('I' if only_I else 'IB'))

Total time: 4.01533 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.create_area_for_next_vertex_join at line 784

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   784                                               def create_area_for_next_vertex_join(self, x:int, y:int, u: int, v: int, force_limit_negative_distance: bool = False) -> DiscreteDisk:
   785    175141    1391924.0      7.9      3.5          distance = self.vertex_edge_distance[u][v]
   786    175141    1261712.0      7.2      3.1          if distance == 1:
   787    126576   25544825.0    201.8     63.6              area = DiscreteDisk.disk(self.unit, x, y, connected = 1)          
   788                                                   else:
   789     48565   10065850.0    207.3     25.1              area = DiscreteDisk.disk(self.unit, x, y, connected = 0)
   790     48565     392749.0      8.1      1.0              if force_limit_negative_distance or self.limit_negative_distances:
   791         1      45875.0  45875.0      0.1                  area = create_area_by_join(area, DiscreteDisk.disk(self.unit * distance, x, y, connected = 1))
   792    175141    1450414.0      8.3      3.6          return area

