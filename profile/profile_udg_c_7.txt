Checking unit: 9
Show only functions ≥ 0.100 s
Timer unit: 1e-07 s

Total time: 0.572382 s

Could not find file <string>
Are you sure you are running this program from the same directory
that you ran the profiler from?
Continuing without the function's contents.

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     2                                           
     3    153384    2003409.0     13.1     35.0  
     4    153384    1740450.0     11.3     30.4  
     5    153375    1979964.0     12.9     34.6  

Total time: 0.592251 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: _get_from_disk_cache at line 95

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    95                                           def _get_from_disk_cache(radius: int, connected: int = 1) -> np.ndarray:
    96    168677    2646246.0     15.7     44.7      if radius not in _disk_cache:
    97         1          9.0      9.0      0.0          size = 2 * radius + 1
    98                                                   # C = Connected, D = Disconnected
    99         1        370.0    370.0      0.0          C = np.full((size, size), MODE_O, dtype=np.uint8)
   100         1         96.0     96.0      0.0          D = np.full((size, size), MODE_I, dtype=np.uint8)
   101        10         71.0      7.1      0.0          for ix in range(1, radius + 1):
   102        54        369.0      6.8      0.0              for iy in range(ix, radius + 1):
   103        45        921.0     20.5      0.0                  if DS[idx(ix, iy)] <= RES[radius]:
   104        30       2964.0     98.8      0.1                      symmetric_set(C, ix, iy, radius, MODE_I)
   105        30       2915.0     97.2      0.0                      symmetric_set(D, ix, iy, radius, MODE_O)
   106                                                           else: # DS[idx(ix, iy)] > RES[radius]
   107        15        283.0     18.9      0.0                      if DS[idx(ix-1, iy-1)] < RES[radius]:
   108         9        853.0     94.8      0.0                          symmetric_set(C, ix, iy, radius, MODE_B)
   109         9        971.0    107.9      0.0                          symmetric_set(D, ix, iy, radius, MODE_B)
   110         6        114.0     19.0      0.0                      elif DS[idx(ix-1, iy-1)] == RES[radius]: # Not symmetric case caused by range (a,b> closed at Top Right
   111                                                                   C[radius - ix + 1, radius - iy + 1] = MODE_B
   112                                                                   C[radius - iy + 1, radius - ix + 1] = MODE_B
   113                                                                   D[radius - ix + 1, radius - iy + 1] = MODE_B
   114                                                                   D[radius - iy + 1, radius - ix + 1] = MODE_B
   115                                                   # Not symmetric case caused by range (a,b> closed at Top Right, out of basic range
   116         1         10.0     10.0      0.0          C[0, radius] = MODE_B
   117         1          9.0      9.0      0.0          C[radius, 0] = MODE_B
   118         1          7.0      7.0      0.0          D[0, radius] = MODE_B
   119         1         12.0     12.0      0.0          D[radius, 0] = MODE_B
   120                                           
   121         1         24.0     24.0      0.0          if C[radius, radius] == MODE_I and not DiscreteDisk.allow_same_positions:
   122                                                       C[radius, radius] = MODE_B
   123                                           
   124         1         37.0     37.0      0.0          C.setflags(write=False)
   125         1         10.0     10.0      0.0          D.setflags(write=False)
   126         1         10.0     10.0      0.0          _disk_cache[radius] = (D, C)
   127                                               
   128    168677    3266214.0     19.4     55.1      return _disk_cache[radius][connected]

Total time: 2.44677 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: DiscreteDisk.__init__ at line 140

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   140                                               def __init__(self, data: np.ndarray, rest: np.uint8, x: int, y: int, _shared: bool = False):
   141    335522    5935039.0     17.7     24.3          self.data = data
   142    335522    4560955.0     13.6     18.6          self.rest = rest
   143    335522    4444102.0     13.2     18.2          self.x = x
   144    335522    4362163.0     13.0     17.8          self.y = y
   145    335522    5165442.0     15.4     21.1          self._shared = _shared

Total time: 4.05601 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: DiscreteDisk.disk at line 163

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   163                                               @classmethod
   164                                               def disk(cls, radius: int = 4, x: int = 0, y: int = 0, connected: int = 1) -> "DiscreteDisk":
   165    168677   14363935.0     85.2     35.4          M = _get_from_disk_cache(radius, connected)
   166    168677   26196163.0    155.3     64.6          return cls(M, MODE_O if connected else MODE_I, x - radius, y - radius, True)

Total time: 6.86936 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: DiscreteDisk.points_list at line 168

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   168                                               def points_list(self, types: str = 'IB') -> list[Coordinate]:
   169                                                   # Vectorized version - znacznie szybsza dla dużych obszarów
   170    152435    2106810.0     13.8      3.1          if types == 'I':
   171    152435   13503668.0     88.6     19.7              mask = (self.data == MODE_I) 
   172                                                   elif types == 'B':
   173                                                       mask = (self.data == MODE_B) 
   174                                                   elif types == 'IB':
   175                                                       mask = (self.data == MODE_I) | (self.data == MODE_B)
   176                                                   else:
   177                                                       raise ValueError(f'Not supported types: {types}')
   178                                                   
   179    152435   31346678.0    205.6     45.6          ys, xs = np.nonzero(mask)
   180    152435    2831730.0     18.6      4.1          if len(ys) == 0:
   181    137603    1958200.0     14.2      2.9              return []
   182                                                       
   183                                                   # Vectorized coordinate creation
   184     14832    1285760.0     86.7      1.9          x_coords = xs + self.x
   185     14832     758598.0     51.1      1.1          y_coords = ys + self.y  
   186     14832    1753828.0    118.2      2.6          values = self.data[ys, xs]
   187                                                   
   188                                                   # List comprehension - szybsze niż pętla for
   189     14832   13148293.0    886.5     19.1          return [Coordinate(x_coords[i], y_coords[i], values[i]) for i in range(len(ys))]

Total time: 14.6454 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\discrete_disk.py
Function: create_area_by_join at line 337

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   337                                           def create_area_by_join(a: DiscreteDisk, b: DiscreteDisk) -> DiscreteDisk:
   338                                               """Join area, increase shape if need."""
   339                                           
   340    168669    3893587.0     23.1      2.7      DiscreteDisk.operation_disk_counter += 1
   341                                           
   342    168669    3427602.0     20.3      2.3      ah, aw = a.data.shape
   343    168669    2601410.0     15.4      1.8      bh, bw = b.data.shape
   344                                               
   345                                               # Basic operation, result is overlap region
   346    168669    4524868.0     26.8      3.1      min_x = max(a.x     , b.x     )
   347    168669    3332282.0     19.8      2.3      min_y = max(a.y     , b.y     )
   348    168669    3998403.0     23.7      2.7      max_x = min(a.x + aw, b.x + bw)
   349    168669    3871947.0     23.0      2.6      max_y = min(a.y + ah, b.y + bh)
   350                                           
   351    168669    2505527.0     14.9      1.7      w = max_x - min_x
   352    168669    2392630.0     14.2      1.6      h = max_y - min_y
   353                                           
   354    168669    2947282.0     17.5      2.0      if w > 0 and h > 0:
   355    166845    2493960.0     14.9      1.7          ax = min_x - a.x
   356    166845    2445467.0     14.7      1.7          ay = min_y - a.y
   357    166845    2606293.0     15.6      1.8          bx = min_x - b.x
   358    166845    2663563.0     16.0      1.8          by = min_y - b.y
   359                                                   
   360                                                   # Optymalizacja: in-place operacja zamiast TBL_AND indexing
   361    166845    6430860.0     38.5      4.4          asub = a.data[ay:ay+h, ax:ax+w]
   362    166845    4657964.0     27.9      3.2          bsub = b.data[by:by+h, bx:bx+w]
   363    166845    7223765.0     43.3      4.9          M = asub.copy()  # Kopia dla zachowania oryginalnych danych
   364    166845   16300569.0     97.7     11.1          np.minimum(M, bsub, out=M)  # in-place AND operation - szybsze niż TBL_AND[asub, bsub]
   365                                               else:
   366      1824      16494.0      9.0      0.0          M = DISK_NONE
   367                                           
   368    168669    3455774.0     20.5      2.4      if a.rest == MODE_O and b.rest == MODE_O:
   369                                                   # Both Outer
   370         8         83.0     10.4      0.0          if M is DISK_NONE:
   371                                                       return DISK_OUTER
   372                                                   else:
   373         8        864.0    108.0      0.0              result = DiscreteDisk(M, MODE_O, min_x, min_y, False)
   374         8        105.0     13.1      0.0              if opts.crop:
   375                                                           return result.crop()
   376         8         79.0      9.9      0.0              return result
   377    168661    2602573.0     15.4      1.8      elif a.rest == MODE_O or b.rest == MODE_O:
   378                                                   # One Outer other Inner
   379    168626    2320972.0     13.8      1.6          if M is DISK_NONE:
   380                                                       # Not overlapping, return the connected disk
   381      1824      17156.0      9.4      0.0              c = a if a.rest == MODE_O else b
   382      1824      16628.0      9.1      0.0              return c
   383                                                   else:
   384    166802    2696588.0     16.2      1.8              c = a if a.rest == MODE_O else b
   385    166802    2540834.0     15.2      1.7              cx = min_x - c.x
   386    166802    2553563.0     15.3      1.7              cy = min_y - c.y
   387    166802    5525459.0     33.1      3.8              OM = c.data.copy()
   388    166802   16288330.0     97.7     11.1              np.copyto(OM[cy:cy+h, cx:cx+w], M)
   389    166802   25232607.0    151.3     17.2              result = DiscreteDisk(OM, MODE_O, c.x, c.y, False)
   390    166802    2509848.0     15.0      1.7              if opts.crop:
   391                                                           return result.crop()
   392    166802    2319639.0     13.9      1.6              return result
   393                                               else:
   394                                                   # Both Inner
   395        35        926.0     26.5      0.0          min_x_oo = min(a.x     , b.x     )
   396        35        704.0     20.1      0.0          min_y_oo = min(a.y     , b.y     )
   397        35        990.0     28.3      0.0          max_x_oo = max(a.x + aw, b.x + bw)
   398        35       1093.0     31.2      0.0          max_y_oo = max(a.y + ah, b.y + bh)
   399                                           
   400        35        645.0     18.4      0.0          w_oo = max_x_oo - min_x_oo
   401        35        545.0     15.6      0.0          h_oo = max_y_oo - min_y_oo
   402                                                   
   403        35      12378.0    353.7      0.0          MOO = np.full((h_oo, w_oo), MODE_I, dtype=np.uint8)
   404                                           
   405        35        848.0     24.2      0.0          ax_oo = a.x - min_x_oo
   406        35        646.0     18.5      0.0          ay_oo = a.y - min_y_oo
   407        35       3676.0    105.0      0.0          np.copyto(MOO[ay_oo:ay_oo+ah, ax_oo:ax_oo+aw], a.data)
   408                                           
   409        35        889.0     25.4      0.0          bx_oo = b.x - min_x_oo
   410        35        593.0     16.9      0.0          by_oo = b.y - min_y_oo
   411        35       3463.0     98.9      0.0          np.copyto(MOO[by_oo:by_oo+bh, bx_oo:bx_oo+bw], b.data)
   412                                           
   413        35        575.0     16.4      0.0          if M is not DISK_NONE:
   414        35        596.0     17.0      0.0              x_oo = min_x - min_x_oo
   415        35        555.0     15.9      0.0              y_oo = min_y - min_y_oo
   416        35       2809.0     80.3      0.0              np.copyto(MOO[y_oo:y_oo+h, x_oo:x_oo+w], M)
   417                                           
   418        35       5649.0    161.4      0.0          result = DiscreteDisk(MOO, MODE_I, min_x_oo, min_y_oo, False)
   419        35        559.0     16.0      0.0          if opts.crop:
   420                                                       return result.crop()
   421        35        496.0     14.2      0.0          return result

Total time: 50.1085 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\profile\profile_udg.py
Function: run_c at line 22

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    22                                           def run_c():
    23         1       4823.0   4823.0      0.0      nxg = Graph6Converter.edge_list_to_graph('9: 1,2 1,3 1,4 1,5 2,5 2,6 2,7 2,8 8,9')
    24         1      41322.0  41322.0      0.0      g = udg.Graph(nxg)
    25         1         81.0     81.0      0.0      g.set_unit(9)
    26         1  501038876.0 5.01e+08    100.0      g.udg_recognition()

Total time: 0.622924 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.set_coordinate at line 173

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   173                                               def set_coordinate(self, v: int, x: int, y: int, mode: np.uint8 = MODE_U):
   174                                                   """Set coordinates for vertex ``v``."""
   175    152436    2107793.0     13.8     33.8          v = self.coordinates[v]
   176    152436    2160151.0     14.2     34.7          v.x, v.y, v.mode = x, y, mode
   177    152436    1961301.0     12.9     31.5          return self

Total time: 0.525016 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.clear_previous_area at line 179

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   179                                               def clear_previous_area(self, order_index: int):
   180    152436    5250161.0     34.4    100.0          for row in self.previous_area: row[order_index] = False

Total time: 0.458863 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.set_iteration_index at line 186

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   186                                               def set_iteration_index(self, v: int, index: int):
   187    152436    2483554.0     16.3     54.1          c = self.iterations[v].point_iter = index
   188    152436    2105078.0     13.8     45.9          return self

Total time: 50.1039 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.udg_recognition at line 384

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   384                                               def udg_recognition(self):
   385         1         41.0     41.0      0.0          self.start_time = time.time()
   386         1         13.0     13.0      0.0          self.last_verbose_time = self.start_time
   387         1          9.0      9.0      0.0          self.last_progress_time = self.start_time
   388                                           
   389         1       1211.0   1211.0      0.0          if not self.is_connected():
   390                                                       self.stop_time = time.time()
   391                                                       if self.log_level >= LOG_BASIC:
   392                                                           print("Graph is not connected, cannot be a UDG.")
   393                                                       return False
   394                                           
   395         1        316.0    316.0      0.0          if self.is_full():
   396                                                       self.stop_time = time.time()
   397                                                       if self.log_level >= LOG_BASIC:
   398                                                           print("Graph is full, it is a UDG.")
   399                                                       return True
   400                                                   
   401         1       2253.0   2253.0      0.0          self.apply_order()
   402                                           
   403         1          8.0      8.0      0.0          self.level = 0
   404         1          8.0      8.0      0.0          while True:
   405         1          8.0      8.0      0.0              if self.log_level >= LOG_BASIC:
   406         1         68.0     68.0      0.0                  print(f"Checking unit: {self.unit}")
   407         1  501034401.0 5.01e+08    100.0              result = self.has_discrete_realization()
   408         1         41.0     41.0      0.0              if result == YES:
   409         1        102.0    102.0      0.0                  self.stop_time = time.time()
   410         1         39.0     39.0      0.0                  return True
   411                                                       if result == NO:
   412                                                           self.stop_time = time.time()
   413                                                           return False
   414                                                       if self.is_limit_achieved():
   415                                                           self.stop_time = time.time()
   416                                                           if self.log_level >= LOG_BASIC:
   417                                                               print("Reached max unit = {self.unit}, no realization found.")
   418                                                           return False
   419                                           
   420                                                       self.refine_granularity()
   421                                                       self.level += 1

Total time: 50.1034 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.has_discrete_realization at line 461

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   461                                               def has_discrete_realization(self):
   462         1         15.0     15.0      0.0          range_modes = [True] if self.optimize_for_yes else [True, False]
   463         1          8.0      8.0      0.0          for only_I in range_modes:
   464         1          8.0      8.0      0.0              if self.log_level >= LOG_INFO:
   465                                                           print(f"  {'Inner' if only_I else 'All'}")
   466         1          7.0      7.0      0.0              count_I: int = 0
   467         1          6.0      6.0      0.0              count_B: int = 0
   468         1  501034041.0 5.01e+08    100.0              result = self.place_next_vertex(0, False, only_I, count_I, count_B)
   469         1         37.0     37.0      0.0              if result == YES:
   470         1         46.0     46.0      0.0                  return YES
   471                                                   return result

Total time: 47.6178 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.place_next_vertex at line 582

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   582                                               def place_next_vertex(self, j: int, calc_D: bool, only_I: bool, count_I: int, count_B: int):
   583    152436    2080812.0     13.7      0.4          if self.order[j] == -1:
   584                                                       P = self.minimize_coordinates(j, only_I, count_I, count_B)
   585                                                   else:
   586    152436  390046457.0   2558.8     81.9              P = self.candidate_points(j, only_I, count_I, count_B)
   587                                           
   588    152436    2024742.0     13.3      0.4          vertex = self.order[j]
   589                                           
   590    152436    2169534.0     14.2      0.5          if self.log_level >= LOG_TRACE:
   591                                                       print(f"order[{j}]={vertex} : {len(P)} points")
   592                                           
   593    152436    1852908.0     12.2      0.4          found_trigraph = False
   594                                           
   595    152436    2326992.0     15.3      0.5          if self.print_progress > 0:
   596                                                       self.set_iteration_len(vertex, len(P))
   597                                                   
   598    152436    1878722.0     12.3      0.4          iter_p = -1
   599    304863    4750823.0     15.6      1.0          for p in P:
   600    152436    1960300.0     12.9      0.4              iter_p += 1
   601    152436   12166384.0     79.8      2.6              self.set_iteration_index(vertex, iter_p)
   602                                           
   603    152436    3236986.0     21.2      0.7              incr_I = 1 if p.mode == MODE_I else 0
   604    152436    2399669.0     15.7      0.5              incr_B = 1 if p.mode == MODE_B else 0
   605                                           
   606    152436   14492826.0     95.1      3.0              self.set_coordinate(vertex, p.x, p.y, p.mode)
   607    152436   10944556.0     71.8      2.3              self.clear_previous_area(j)
   608                                           
   609    152436    2573471.0     16.9      0.5              self.place_next_vertex_counter += 1
   610    152436    2245637.0     14.7      0.5              if self.collect_work_summary:
   611                                                           self.mark_place_next_vertex_process(j)
   612                                                       
   613    152436    1993697.0     13.1      0.4              if (self.print_progress > 0) and (time.time() - self.last_progress_time > self.print_progress):
   614                                                           self.last_progress_time = time.time()
   615                                                           if time.time() - self.last_verbose_time > 10:
   616                                                               self.last_verbose_time = time.time()
   617                                                               print("  placing " + self.state_info(only_I, j))
   618    152436    2273107.0     14.9      0.5              if (self.log_level >= LOG_DEBUG) or (self.log_level == LOG_WORK_ORDER):
   619                                                           print(f"vertex = {self.order[j]} already_placed = {j} coordinates = {self.print_coordinates(j)}")
   620    152436    2022734.0     13.3      0.4              if j < self.n - 1:
   621    152435    2316677.0     15.2      0.5                  result = self.place_next_vertex(j + 1, calc_D, only_I, count_I + incr_I, count_B + incr_B)
   622    152435    2218661.0     14.6      0.5                  if result == YES:
   623         8        338.0     42.2      0.0                      return YES
   624    152427    1901951.0     12.5      0.4                  if result == TRIGRAPH:
   625                                                               if not only_I:
   626                                                                   return TRIGRAPH
   627                                                               if not calc_D:
   628                                                                   found_trigraph=True
   629    152427    1967185.0     12.9      0.4                  if not only_I and (result == NO):
   630                                                               # TODO print(f"XXX {self.unit} {j} forbidden at {self.state_info(only_I, j)}")
   631                                                               pass
   632                                                       else:
   633                                                           # if self.is_udg_realization():
   634         1         67.0     67.0      0.0                  if count_I + incr_I == self.n:
   635         1         43.0     43.0      0.0                      if calc_D:
   636                                                                   self.store_vertex_distances(MODE_I)
   637                                                                   self.result_I += 1
   638                                                               else:
   639         1         37.0     37.0      0.0                          return YES
   640                                                           if not only_I:
   641                                                               if calc_D:
   642                                                                   self.store_vertex_distances(MODE_B)
   643                                                                   self.result_B += 1
   644                                                               else:
   645                                                                   return TRIGRAPH
   646                                                           if not calc_D:
   647                                                               found_trigraph = True
   648                                                   
   649    152427    1883694.0     12.4      0.4          if not found_trigraph:
   650    152427    2448568.0     16.1      0.5              return TRIGRAPH if self.optimize_for_yes else NO
   651                                           
   652                                                   return TRIGRAPH

Total time: 38.2626 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.candidate_points at line 687

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   687                                               def candidate_points(self, j: int, only_I: bool, count_I: int, count_B: int) -> list[Coordinate]:
   688    152436  378595228.0   2483.6     98.9          P = self.candidate_points_without_order(j, only_I, count_I, count_B)
   689                                           
   690                                                   # Ultra-fast pre-compiled sorting - eliminuje if-elif chain
   691    152436    2045836.0     13.4      0.5          if self._point_sort_key is not None:
   692                                                       P.sort(key=self._point_sort_key)
   693                                                   # else: keep original order (no sorting needed)
   694                                           
   695    152436    1984476.0     13.0      0.5          return P

Total time: 35.9984 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.candidate_points_without_order at line 712

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   712                                               def candidate_points_without_order(self, j: int, only_I: bool, count_I: int, count_B: int) -> list[Coordinate]:
   713    152436    1920541.0     12.6      0.5          if j == 0:
   714         1          8.0      8.0      0.0              P = []
   715         1         91.0     91.0      0.0              P.append(Coordinate(x = 0, y = 0, mode = MODE_I))
   716         1          7.0      7.0      0.0              return P
   717    152435    1883178.0     12.4      0.5          if j == 1:
   718         1          7.0      7.0      0.0              """ Previous is 0, so coordinate is equal (0,0) """
   719         1      11315.0  11315.0      0.0              area = self.create_area_for_next_vertex_join(0, 0, self.order[0], self.order[1], True)
   720         1          9.0      9.0      0.0              if self.limit_points:
   721         1       9814.0   9814.0      0.0                  P = [p for p in area.points_list(types = ('I' if only_I else 'IB')) if p.y == 0 and p.x >= 0]
   722                                                       else:
   723                                                           P = [p for p in area.points_list(types = ('I' if only_I else 'IB')) if p.y >= 0 and p.x >= 0]
   724                                           
   725         1         13.0     13.0      0.0              if self.check_distance:
   726                                                           if self.check_distance_iteration >= len(P) - 1:
   727                                                               # This is the last index, handle accordingly
   728                                                               p = P[-1]  # Get the last element
   729                                                               self.check_distance = False  # Stop further iterations
   730                                                           else:
   731                                                               p = P[self.check_distance_iteration]
   732                                                           P = []
   733                                                           P.append(p)
   734                                                       
   735         1          8.0      8.0      0.0              return P
   736                                           
   737    152434    1858156.0     12.2      0.5          i = j - 2
   738    168676    2603413.0     15.4      0.7          while i >= 0 and self.previous_area[j][i] is False:
   739     16242     228754.0     14.1      0.1              i -= 1
   740                                                   
   741    321110    6173345.0     19.2      1.7          for k in range(i+1, j):
   742    168676    2328497.0     13.8      0.6              coord_v_order_k = self.coordinates[self.order[k]]
   743    168676   69242784.0    410.5     19.2              area = self.create_area_for_next_vertex_join(coord_v_order_k.x, coord_v_order_k.y, self.order[j], self.order[k])
   744    168676    2167752.0     12.9      0.6              if k > 0:
   745    168669    2446287.0     14.5      0.7                  prev_area = self.previous_area[j][k-1]
   746    168669  181601184.0   1076.7     50.4                  area = create_area_by_join(prev_area, area) 
   747    168676    2903312.0     17.2      0.8              self.previous_area[j][k] = area
   748                                           
   749    152434    1822642.0     12.0      0.5          """For limit points return only positive y coordinates for second vertex"""
   750    152434    1878080.0     12.3      0.5          if j == 2:
   751         8         86.0     10.8      0.0              if self.limit_points:
   752         8      94160.0  11770.0      0.0                  P = [p for p in area.points_list(types = ('I' if only_I else 'IB')) if p.y >= 0]
   753         8        110.0     13.8      0.0                  return P
   754                                                       else:
   755                                                           return area.points_list(types = ('I' if only_I else 'IB'))
   756                                                   else: 
   757    152426   80810369.0    530.2     22.4              return area.points_list(types = ('I' if only_I else 'IB'))

Total time: 5.83909 s
File: C:\Users\piotr\OneDrive\StDoc\proj\UDG\UDG\udg.py
Function: Graph.create_area_for_next_vertex_join at line 759

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   759                                               def create_area_for_next_vertex_join(self, x:int, y:int, u: int, v: int, force_limit_negative_distance: bool = False) -> DiscreteDisk:
   760    168677    2317240.0     13.7      4.0          distance = self.vertex_edge_distance[u][v]
   761    168677    2018063.0     12.0      3.5          if distance == 1:
   762       181      57340.0    316.8      0.1              area = DiscreteDisk.disk(self.unit, x, y, connected = 1)          
   763                                                   else:
   764    168496   49465888.0    293.6     84.7              area = DiscreteDisk.disk(self.unit, x, y, connected = 0)
   765    168496    2228025.0     13.2      3.8              if force_limit_negative_distance or self.limit_negative_distances:
   766                                                           area = create_area_by_join(area, DiscreteDisk.disk(self.unit * distance, x, y, connected = 1))
   767    168677    2304365.0     13.7      3.9          return area

